---
title: 人工神经网络
tags: 
	- 机器学习
	- 人工神经网络
categories:
	- 机器学习
---

# 人工神经网络

人工神经网络(Artificial Neural Networks, ANN) 提供了一种普遍而且实用的方法从样例中学习值为实数、离散值或向量的函数。像反向传播(BACKPROPAGATION)这样的算法，实用梯度下降来调节网络参数以最佳拟合由输入-输出对组成的训练集合。ANN学习对于训练数据中的错误健壮性很好。

## 简介

神经网络学习方法对于逼近实数值、离散值和向量值得目标函数提供了一种健壮性很强的方法。

人工神经网络是由一系列简单的单元相互密集连接构成的，其中每一个单元有一定数量的实值输入（可能是其他单元的输出），并产生单一的实数值输出（可能成为其它很多单元的输入）。

ANN系统的一个动机就是获取基于分布表示的高度并行算法。

反向传播算法假定网络是一个固定结构，对应一个有向图，可能包含环。ANN学习就是为图中的每一条边选取权值。

## 适合神经网络学习的问题

ANN学习非常适合于这样的问题：训练集合为含有噪声的复杂传感器数据。它也适用于需要许多符号表示的问题。反向传播是最常用的ANN学习技术。它适合具有以下特征的问题：

- 实例是用很多属性-值对表示：要学习的目标函数是定义在可以用向量描述的实例之上的，向量由预先定义的特征组成。
- 目标函数的输出可能是离散值、实数值或者由若干实数属性或离散属性组成的向量。
- 训练数据可能包含错误：ANN学习算法对于训练数据中的错误有非常好的健壮性
- 可容忍长时间的训练
- 可能需要快速求出函数值
- 人类能否理解学到的目标函数是不重要的

组成神经网络的几种主要单元：感知器（perceptron）、线性单元（linear unit）和sigmoid单元（sigmoid unit）。

## 感知器

一种类型的ANN系统是以被称为感知器的单元为基础的。**感知器**以一个实数值向量作为输入，计算这些输入的线性组合，然后如果结果大于某个阈值，就输出1，否则输出-1。更精确地，如果输入为 $$x_1$$ 到 $$x_n$$ ，那么感知器计算的输出为：

$$ o(x_1, …, x_n) = \begin{cases} 1 & if\ w_0+w_1x_1+w_2x_2+…+w_nx_n > 0 \\ -1 & otherwise \end{cases} $$

其中每一个 $$w_i$$ 是一个实数常量，或叫做权值，用来决定输入 $$x_i$$ 对感知器输出的贡献率。数量（$$-x_0$$）是一个阈值，它是为了使感知器输出1，输入的加权和 $$w_1x_1+w_2x_2+…+w_nx_n$$ 必须超过的阈值。

有时会把感知器函数写为：

$$o(\vec{x}) = sgn(\vec{w} \cdot \vec{x})$$

其中

$$sng(y) = \begin{cases} 1 & if\ y > 0 \\ -1 & otherwise \end{cases}$$

学习一个感知器意味着选择权 $$w_0, … , w_n$$ 的值。所以感知器学习要考虑的候选假设空间 $$H$$ 就是所有可能的实数值权向量的集合。

$$H = \{  \vec{w} | \vec{w} \in \Re ^{(n+1)} \}$$

### 感知器的表征能力

可以把感知器看作是 n 维实例空间（即点空间）中的超平面决策面。对于超平面一侧的实例，感知器输出1，对于另一侧的实例输出-1。某些正反样例集合不可能被任一超平面分割，那些可以被分割的称为线性可分样例集合。

### 感知器训练法则

从如何学习单个感知器的权值开始。准确地说，这里的学习任务是决定一个权向量，它可以使感知器对于给定的训练样例输出正确的1或-1。解决这个学习任务的算法有感知器法则和delta法则等。这两种算法保证收敛到可接受的假设。这两种方法对于ANN很重要，因为它们提供了学习多个单元构成的网络的基础。

为得到可接受的权向量，一种办法是从随机的权值开始，然后反复地应用这个感知器到每个训练样例，只要它误分类样例就修改感知器的权值。重复这个过程，知道感知器正确分类所有的训练样例。每一步根据感知器训练法则来修改权值，也就是修改与输入 $$x_i$$ 对应的权 $$w_i$$ ，法则如下：

$$w_i \leftarrow w_i + \Delta w_i$$

其中：

$$\Delta w_i = \eta (t - o) x_i$$

这里 t 是当前训练样例的目标输出，o 是感知器的输出，$$\eta$$ 是一个正的常数称为学习速率。学习速率的作用是缓和每一步调整权的程度。它通常被设为一个小的数值（如：0.1），而且有时会使其随着权调整次数的增加而衰减。

可以证明，在有限次地使用感知器训练法则后，训练过程会收敛到一个能正确分类所有训练样例的权向量，前提是训练样例线性可分，并且使用了充分小的 $$\eta$$ 。如果数据不是线性可分的，那么不能保证训练过程收敛。

### 梯度下降和delta法则

如果训练样本不是线性可分的，那么delta法则会收敛到目标概念的最佳近似。

delta法则的关键思想是使用梯度下降来搜索可能的权向量的假设空间，以找到最佳拟合训练样例的权向量。

delta法则的重要性在于：

- 它为反向传播算法提供了基础，而反向传播算法能够学习多个单元的互连网络
- 对于包含多种不同类型的连续参数化假设的假设空间，梯度下降是必须遍历这样的假设空间的所有学习算法的基础

最好把delta训练法则理解为训练一个无阈值的感知器，也就是一个线性单元，它的输出 o 如下：

$$o(\vec{x})  = \vec{w} \cdot \vec{x}$$

为了推导线性单元的权值学习法则，先指定一个度量标准来衡量假设（权向量）相对于训练样例的训练误差：

$$E(\vec{w})  \equiv \frac{1}{2} \sum \limits _{d \in D} (t_d - o_d) ^2$$

其中，D 是训练样例集合， $$t_d$$ 是训练样例 $$d$$ 的目标输出，$$o_d$$ 是线性单元对训练样例 $$d$$ 的输出。

#### 可视化假设空间

为了确定一个使 E 最小化的权向量，梯度下降搜索从一个任意的初始权向量开始，然后以很小的步伐反复修改这个向量。每一步都沿误差曲面产生最陡峭下降的方向修改权向量，继续这个过程知道得到全局的最小误差点。

#### 梯度下降法则的推导

通过计算 $$E$$ 相对向量 $$\vec{w}$$ 的每个分量的导数来得到这个方向。这个向量导数被称为 $$E$$ 对于 $$\vec{w}$$ 的**梯度**，记作 $$\nabla E(\vec{w}) \equiv [ \, \frac {\partial E}{\partial w_0},\frac {\partial E}{\partial w_1},…,\frac {\partial E}{\partial w_n}  ] \,$$

$$\nabla E(\vec{w})$$ 本身是一个向量，它的成员时 $$E$$ 对每个 $$w_i$$ 的偏导数。当梯度被解释为权空间的一个向量时，它确定了使 $$E$$ 最陡峭上升的方向。所以，这个方向的反方向给出了最陡峭下降的方向。那么梯度下降的训练法则是：

$$\vec {w} \leftarrow \vec{w} + \Delta \vec{w}$$

其中：

$$\Delta \vec w = - \eta \nabla E (\vec w)$$

 这里 $$\eta$$ 是一个正的常数叫学习速率，它决定梯度下降搜索中的步长。这个训练法则也可以写成它的分量形式：

$$w_i = w_i + \Delta w_i$$

其中：

$$\Delta w_i = - \eta \frac{\partial E}{\partial w_i}$$

最陡峭的下降可以按照比例 $$\frac{\partial E}{\partial w_i}$$ 改变 $$\vec{w}$$ 中的每一个分量 $$w_i$$ 来实现。

我们需要一个高效的方法，在每一步都计算这个梯度：从训练误差公式($$E(\vec{w})  \equiv \frac{1}{2} \sum \limits _{d \in D} (t_d - o_d) ^2$$)中计算 $$E$$ 的微分，从而得到组成这个梯度向量的分量 $$\frac{\partial \vec{E}}{\partial w_i}$$ ：

$$\frac{\partial \vec{E}}{\partial w_i} = \sum \limits _{d \in D} (t_d-o_d)(-x_{id})$$

其中，$$x_{id}$$ 表示训练样例 $$d$$ 的一个输入分量 $$x_i$$ 。

梯度下降权值更新法则：

$$\Delta w_i = \eta \sum \limits _{d \in D} (t_d - o_d) x_{id}$$

训练线性单元的梯度下降算法：

---

GRADIENT-DESCENT(training_examples, n)

_training_examples_ 中每一个训练样例形式为序偶 $$<\vec{x}, t>$$，其中 $$\vec{x}$$ 是输入值向量， t 是目标输出值， $$\eta$$ 是学习速率，

- 初始化每个 $$w_i$$ 为某个小的随机值

- 遇到终止条件之前，做以下操作

  - 初始化每个 $$\Delta w_i$$ 为0

  - 对于训练样例 _training_examples_ 中的每个 $$<\vec{x}, t>$$ ，做：

    - 把实例 $$\vec{x}$$ 输入到此单元，计算输出 o ($$o(\vec{x}) = \vec{w} \cdot \vec{x}$$)

    - 对于线性单元的每个权 $$w_i$$ ，做

      $$\Delta w_I \leftarrow \Delta w_i + \eta (t - o) x_i$$

    - 对于线性单元的每个权 $$w_i$$ ，做：

      $$w_i \leftarrow w_i + \Delta w_i$$

---

#### 梯度下降的随机近似

梯度下降是一种重要的通用学习范型。它是搜索庞大假设空间或无限假设空间的一种策略，它可应用于满足以下条件的任何情况：

- 假设空间包含连续参数化的假设
- 误差对于这些假设参数可微

应用梯度下降的主要实践问题：

- 收敛过程可能非常慢
- 误差曲面上有多个局部极小值，那么不能保证这个过程会找到全局最小值

缓解上述问题的一个常见的梯度下降变体被称为 **增量梯度下降** 或 **随机梯度下降** 。随机梯度下降的思想是根据每个单独样例的误差增量计算权值更新，得到近似的梯度下降搜索。

标准的梯度下降和随机的梯度下降之间的关键区别是：

- 标准的梯度下降是在权值更新前对所有样例汇总误差，而随机梯度下降的权值是通过考察每个训练实例来更新
- 在标准的梯度下降中，权值更新的每一步对多个样例求和，这需要更多的计算。另一方面，因为使用真正的梯度，标准的梯度下降对于每一次权值更新经常使用比随机梯度下降大的步长
- 如果 $$E(\vec{w})$$ 有多个局部极小值，随机的梯度下降有时可能避免陷入这种局部极小值中，因为它使用不同的 $$\nabla E_d(\vec{w})$$ 而不是 $$\nabla E(\vec{w})$$ 来引导搜索

随机梯度下降在迭代计算每个训练样例时根据下面的公式来更新权值：

$$\Delta w_i = \eta (t-o) x_i$$

上述公式，被称为增量法则，或叫LMS法则（least-mean -square 最小均方）、Adaline法则或Window-Hoff法则。

### 小结

感知器训练法则和增量法则差异：

- 感知器训练法则根据阈值化的感知器输出的误差更新权值
- 增量法则根据输入的非阈值化线性组合的误差来更新权

感知器训练法则经过有限次的迭代收敛一个能理想分类训练数据的假设，但条件是 **训练样例是否线性可分都会收敛** 。

学习权向量的第三种方法是线性规划。这种方法仅当训练样例线性可分时有解。

## 多层网络和反向传播算法

单个感知器仅能表示线性决策面。反向传播算法所学习的多层网络能够表示种类繁多的非线性曲面。

### 可微阈值单元

多个线性单元的连接仍是线性函数。

不连续阈值使它不可微，所以不适合梯度下降算法。

sigmoid单元是一种类似于感知器的单元，但它基于一个平滑的可微阈值函数。sigmoid单元阈值输出是输入的连续函数。sigmoid单元这样计算它的输出：

$$ o = \sigma (\vec{w} \cdot \vec{x}) $$

其中：

$$ \sigma (y) = \frac{1}{1 + e ^{-y}} $$

$$ \sigma $$ 经常被称为sigmoid函数或者也可以称为logistic函数。它的输出范围是0到1，随输入单调递增。因为这个函数把非常大的输入值域映射到一个小范围的输出，它经常被称为sigmoid单元的挤压函数。sigmoid函数有一个有用的特征，就是它的导数很容易用它的输出表示。

### 反向传播算法

对于由一系列确定的单元互连形成的多层网络，反向传播算法可用来学习这个网络的权值。它采用梯度下降方法试图最小化网络输出值和目标值之间的误差平方。

**反向传播算法面临的学习问题是搜索一个巨大的搜索空间，这个空间由网络中所有单元的所有可能的权值定义。**

多层网络中，误差曲面可能有多个局部极小值，梯度下降仅能保证收敛到局部极小值，而未必得到全局最小的误差。

包含两层sigmoid单元的前馈网络的反向传播算法（随机梯度下降版本）

---

BACKPROPAGATION(_training_examples_, $$\eta$$ , $$n_{in}$$, $$n_{out}$$, $$n_{hidden}$$ )

$$training\_examples$$ 中每一个训练样例是形式为 $$<\vec{x}, \vec{t}>$$ 的序偶，其中 $$\vec{x}$$ 是网络输入值向量，$$\vec{t}$$ 是目标输出值， $$\eta$$ 是学习速率。$$n_{in}$$ 是网络输入的数量，$$n_{hidden}$$ 是隐藏层单元数，$$n_{out}$$ 是输出单元数。

从单元 $$i$$ 到单元 $$j$$ 的输入表示为 $$x_{ji}$$ 单元 $$i$$ 到单元 $$j$$ 的权值表示为 $$w_{ji}$$ 。

- 创建具有 $$n_{in}$$ 个输入，$$n_{hidden}$$ 个隐藏单元，$$n_{out}$$ 个输出单元的网络。

- 初始化所有的网络权值为小的随机值（例如，-0.05到0.05之间de 数）

- 在遇到终止条件前

  - 对于训练样例 $$training\_examples$$ 中的每个单元$$<\vec{x}, \vec{t}>$$:

    把输入沿网络前向传播

    - 把实例 $$\vec{x}$$ 输入网络，并计算网络中每个单元 $$u$$ 的输出 $$o_u$$ 

    使误差沿网络反向传播

    - 对于网络的每个输出单元 $$k$$，计算它的误差项 $$\delta _k$$

      $$\delta_k \leftarrow o_k (1-o_k)(t_k-o_k)$$

    - 对于网络的每个隐藏单元 $$h$$，计算它的误差项 $$\delta_h$$ 

      $$\delta_h \leftarrow o_h(1-o_h)\sum \limits _{k \in outputs} w_{kh} \delta_k$$

    - 更新每个网络权值 $$w_{ji}$$

      $$w_{ji} \leftarrow w_{ji} + \Delta w_{ji}$$

      其中

      $$\Delta w_{ji} = \eta \delta _j x_{ji}$$

---

 终止判据的条件是很重要的，因为太少的迭代可能无法有效地降低误差，而太多的迭代会导致对训练数据的过度拟合。

#### 增加冲量项

使第 n 次迭代时的权值的更新部分地依赖于发生在第 n-1 次迭代时的更新。

冲量项具有在梯度不变的区域逐渐增大搜索步长的效果，从而可以加快收敛。

## 反向传播算法的说明

### 收敛性和局部极小值

反向传播算法实现了一种对可能的网络权值空间的梯度下降搜索，它迭代地减小训练样例的目标值和网络输出间的误差。对于多层网络，反向传播算法仅能保证收敛到误差 $$E$$ 的某个局部最小值，不一定收敛到全局最小误差。

环节局部极小值问题的常见启发式规则包括：

- 为梯度更新法则加一个冲量项
- 使用随机的梯度下降而不是真正的梯度下降
- 使用同样的数据训练多个网络，但用不同的随机权值初始化每个网络

### 前馈网络的表征能力

- 布尔函数：任何布尔函数可以被具有两层单元的网络准确表示
- 连续函数：每个有界的连续函数可以由一个两层的网络以任意小的误差逼近
- 任意函数：任意函数可以被一个有三层单元的网络以任意精度逼近

有限深度的前馈神经网络为反向传播算法提供了非常有表征力的假设空间。

### 隐藏层表示

反向传播算法能够在网络内部的隐藏层发现有用的中间表示。

多层网络在隐藏层自动发现有用表示的能力是ANN学习的一个关键特性，它提供了一种相当重要的灵活性 - 允许学习器创造出设计者没有明确引入的特征。当然，这些创造出的特征一定是网络输入的sigmoid单元函数可以计算出的。网络中使用的单元层越多，就可以创造出越复杂的特征。

### 泛化、过度拟合和停止判据

反向传播算法容易过度拟合训练样例，降低对于其他未见实例的泛化精度。

过度拟合的内在原因：权值拟合了训练样例的**特异性**，而这个特异性对于样例的一般分布没有代表性。ANN中大量的权值参数为拟合这样的特异性提供了很大的自由度。

随着训练的进行：

- 一些权值开始增长，以降低在训练数据上的误差
- 学习到的决策面的复杂度也在提高
- 反向传播算法获得的假设的有效复杂度也在增加

如果权值调整迭代次数足够多，反向传播算法经常会产生过度复杂的决策面，拟合了训练数据中噪声和训练样例中没有代表性的特征。

解决过度拟合问题方法：

- 权值衰减：它在每次迭代过程中以某个小因子降低每个权值。这等效于修改 $$E$$ 的定义，加入一个与网络权值的总量相应的惩罚项。此方法的动机在于保持权值较小，从而使学习过程向着复杂决策面的反方向偏置
- 验证数据集：解决过度拟合问题的一个最成功的方法就是在训练数据外再为算法提供一套验证数据
- k-fold交叉验证：过度拟合的问题对于小数据集合最为严重。在这种情况下，有时使用一种称为 **k-fold交叉验证** 的方法。这种方法进行k次不同的交叉验证，每次使用数据的不同分割作为训练集合和验证集合，然后对结果进行平均。