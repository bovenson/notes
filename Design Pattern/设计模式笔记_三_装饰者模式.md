---
title: 设计模式 - 装饰者模式
tags: 设计模式, 装饰者模式
---

# 装饰者模式

**装饰者模式** 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

利用**组合**和**委托**可以在运行时具有继承行为的效果。利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。通过动态地组合对象，可以写新的代码添加新功能，而无需修改现有代码。

**设计原则（开放-关闭原则）：** 类应该对扩展开放，对修改关闭。我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性，可以应对改变，可以接受新的功能来应对改变的需求。

# 案例

## 星巴兹

### 最初的设计

最初订单系统设计，如下图。

![](img/note-03-01.png)

星巴兹根据加入调料收费后：

![](img/note-03-02.png)

### 使用实例变量和继承

如果使用**实例变量**和**继承**实现：

![](img/note-03-03.png)

![](img/note-03-04.png)

实现示例：

![](img/note-03-05.png)

#### 问题

- 调料价钱的改变会使我们更改现有代码
- 一旦出现新的调料，需要加上新的方法，并改变超类中的cost()方法
- 以后可能会开发出新饮料，对这些饮料来说，某些调料可能并不合适
- 无法满足顾客配料加倍的需求