---
title: 设计模式 - 工厂模式
tags: 设计模式, 工厂模式, 工厂方法模式, 抽象工厂模式
---

# 工厂模式

- 工厂方法模式
- 抽象工厂模式

## 工厂方法模式

### 定义

**工厂方法模式** 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

## 抽象工厂模式

### 定义

**抽象工厂模式** 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

## 引言

我们不应该针对实现编程，但是当我们每次使用new时，就会想到“具体”。使用new时，的确是在实例化一个具体类，所以用的确实是实现，而不是接口。我们知道，代码绑定具体类会导致代码更脆弱，更缺乏弹性。

![](img/note-04-01.png)

当看到这样的代码，一旦有变化或扩展，就必须重新打开这段代码进行检查和修改。通常这样修改过的代码将造成部分系统更难维护和更新，而且也更容易犯错。

针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。因为，如果代码是针对接口而写，那么通过多态，它可以与任何新类实现该接口。

当代码使用大量具体类时，一旦进入新的具体类，就必须改变代码。也就是说，你的代码并非“对修改关闭”。

解决上述问题，就需要“找出会变的方面，把它们从不变的部分分离出来”。

# 案例

## 披萨工厂

### 识别变化的方面

假如你有一个披萨店，你的代码可能这样写：

![](img/note-04-02.png)

如果需要更多的披萨类型，则需要增加代码，来决定适合的比萨类型，然后再制造这个披萨：

![](img/note-04-03.png)

如果，此时，披萨的类型发生了很多变化：

![](img/note-04-04.png)

很明显，实例化某些具体类，将使orderPizza()出问题，而且也无法让orderPizza()对修改关闭。但是，我们已经知道了那些地方会改变，那些地方不会，接下来就是使用封装的时候了。

### 封装变化的部分

![](img/note-04-05.png)

### 建立简单的工厂

定义一个类，为所有比萨封装创建对象的代码：

![](img/note-04-06.png)

几个问题：

![](img/note-04-07.png)