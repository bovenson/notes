[TOC]

# 魔术方法

- "魔术方法"指被用于重载`Python`的操作符或内置方法
- 每个魔术方法都有特定的目的, 当特定语法出现时, 它作为执行的钩子(钩子是指在特定事件发生时, 能够为响应事件而调用的代码或函数, 回调函数算是钩子的一种)
- 魔术方法需要特定的函数名称和签名, 然后会在特定情况下被调用

## 可用的魔术方法

### 创建与销毁

#### `___init__`方法

- 在创建实例后会立即执行对象的`__init__`方法

- 该方法必须接受一个位置参数(self), 然后可以接受任意数量的可选参数

- 该方法并没有创建新对象(该操作由`__new__`完成), 只在为创建后的对象提供初始化数据

- `__init__`方法并不返回任何值, 如果使用`return`语句返回值则会导致`TypeError`错误

  ```python
  import sys
  print("Python版本信息: ", sys.version)

  class Person(object):
      def __init__(self, name='name'):
          self.name = name
          return name
      pass
  p = Person()
  ```

  **输出**

  ```shell
  D:\Software\Installed\Python\Python36\python.exe D:/workspace/Pycharm/PurePythonProject/Test07.py
  Python版本信息:  3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)]
  Traceback (most recent call last):
    File "D:/workspace/Pycharm/PurePythonProject/Test07.py", line 13, in <module>
      p = Person()
  TypeError: __init__() should return None, not 'str'

  Process finished with exit code 1
  ```

#### `__new__`方法

- `__new__`方法在`__init__`之前执行, 用于创建类的实例, `__new__`方法才是实际上创建并返回实例的方法

- `__new__`永远是静态的

- **简单实例**

  ```python
  import sys

  print("Python版本信息: ", sys.version)

  class Person(object):
      def __new__(cls, *args, **kwargs):
          instance = super(Person, cls).__new__(cls)
          print('Person.__new__(A): ', kwargs)
          kwargs['name'] = 'Snow'
          kwargs['age'] = '20'
          print('Person.__new__(B): ', kwargs)
          instance.name = 'Go'
          return instance
          pass
          
      def __init__(self, *args, **kwargs):
          self.name = kwargs.get('name')
          print('Person.__init__: ', kwargs)
          pass
      pass
  class Teacher(Person):
      def __new__(cls, *args, **kwargs):
          instance = super(Teacher, cls).__new__(cls, *args, **kwargs)
          kwargs['salary'] = '3000'
          print('Teacher.__new__: ', kwargs)
          instance.name = 'Join'
          return instance
          pass
    
      def __init__(self, *args, **kwargs):
          super().__init__(*args, **kwargs)
          self.salary = kwargs.get('salary')
          print('Teacher.__init__: ', kwargs)
          pass

  p = Person(name='Hodor')
  print(p.name)

  print('\n', '*' * 50, '\n')

  t = Teacher(name='Hodor', salary='5000')
  print(t.name, t.salary)
  ```

  **输出**

  ```shell
  D:\Software\Installed\Python\Python36\python.exe D:/workspace/Pycharm/PurePythonProject/Test07.py
  Python版本信息:  3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)]
  Person.__new__(A):  {'name': 'Hodor'}
  Person.__new__(B):  {'name': 'Snow', 'age': '20'}
  Person.__init__:  {'name': 'Hodor'}
  Hodor

   ************************************************** 

  Person.__new__(A):  {'name': 'Hodor', 'salary': '5000'}
  Person.__new__(B):  {'name': 'Snow', 'salary': '5000', 'age': '20'}
  Teacher.__new__:  {'name': 'Hodor', 'salary': '3000'}
  Person.__init__:  {'name': 'Hodor', 'salary': '5000'}
  Teacher.__init__:  {'name': 'Hodor', 'salary': '5000'}
  Hodor 5000

  Process finished with exit code 0
  ```

- 大多数情况下, `__new__`方法的其他参数会被完整复制到`__init__`方法中

- 参数在调用构造函数时首先会被传递给`__new__`方法(由于先被调用)

- 从上例可以看出, 参数在`__new__`方法中无法被修改

#### `__del__`方法

- `__del__`方法在对象被销毁时调用
- 无论是直接删除或是由垃圾回收器进行销毁, 都会调用`__del__`方法

### 类型转换

在`Python`中有很多用于将复杂对象转换为简单对象或常用数据类型的魔术方法.

#### `__str__`

该方法接受一个位置参数`self`, 并在对象被传递给`str`的构造函数时被调用, 然后返回一个字符串.

```shell
deepin@ThinkCentre:~/Desktop$ python3
Python 3.5.2+ (default, Nov  3 2016, 11:10:16) 
[GCC 6.2.0 20161027] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> class MyObject(object):
...     def __str__(self):
...             return "My Awesome Object!"
... 
>>> str(MyObject())
'My Awesome Object!'
```

-   `Python2`中有`__unicode__`方法, 该方法在对象传递给`unicode`的构造函数时被调用
-   `Python3`中有`__bytes__`方法, 该方法在对象传递给`bytes`的构造方法时被调用

#### `__bool__`

用来界定对象`True`或`False`.该类型的操作, 在`Python3`中由`__bool__`魔术方法处理, 在`Python2`中由`__nonzero__`魔术方法处理.

#### `__int__`, `__float__`, `__complex__`

某些情况下, 将复杂对象转换为基本类型的数字十分有价值. 如果一个对象定义了一个返回INT类型的`__int__`方法, 那么该对象被传递给int的构造函数时, `__int__`方法会被调用.

### 比较

对象在进行相等性测试(`==`或`!=`)或不等性测试(`<`, `<=`等)时进行比较, 这些操作符与Python中的魔术方法一一对应.

