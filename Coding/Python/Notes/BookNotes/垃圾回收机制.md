---
title: Python垃圾回收机制
tags:
	- Python
categories:
	- Python
---

# 内存管理机制

- 引用计数
- 垃圾回收

# Python垃圾回收机制

- Python是动态类型的语言，**对象与引用分离**

- 使用 `id` 查看对象内存地址

  ```shell
  >>> a = 1
  >>> id(a)
  4510816880
  >>> hex(id(a))
  '0x10cdd9a70'
  ```

- `is`用于判断两个引用所指的对象是否相同

  ```shell
  >>> a = 1
  >>> b = 1
  >>> a is b
  True
  >>> a = "hello"
  >>> b = "hello"
  >>> a is b
  True
  >>> a = "long long long long string"
  >>> b = "long long long long string"
  >>> a is b
  False
  >>> a = []
  >>> b = []
  >>> a is b
  False
  ```

  - **注：**在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。

- 在Python中，每个对象都有存有指向该对象的引用总数，即**引用计数**(reference count)。

- 我们可以使用`sys`包中的`getrefcount()`，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给`getrefcount()`时，参数实际上创建了一个临时的引用。因此，`getrefcount()`所得到的结果，会比期望的多1。

  ```shell
  >>> from sys import getrefcount
  >>> a = [1, 2, 3]
  >>> print(getrefcount(a))
  2
  >>> b = a
  >>> print(getrefcount(a))
  3
  >>> print(getrefcount(a))
  3
  >>> 
  ```

- **对象引用对象**

  - 对象引用对象，是Python最基本的构成方式。

  - 当一个对象A被另一个对象B引用时，A的引用计数将增加1。

    ```shell
    >>> from sys import getrefcount
    >>> a = [1, 2, 3]
    >>> getrefcount(a)
    2
    >>> b = [1, 2, a]
    >>> getrefcount(a)
    3
    >>> id(b[2])
    4518754888
    >>> id(a)
    4518754888
    ```

  - 容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系

- 两个对象可能相互引用，从而构成所谓的**引用环**(reference cycle)。

- **垃圾回收**

  - 从**基本原理**上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。

  - 垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，**自动启动垃圾回收**。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。

    ```shell
    # 通过gc模块的get_threshold()方法，查看该阈值:
    >>> import gc
    >>> gc.get_threshold()
    (700, 10, 10)
    ```

  - 后面的两个10是与分代回收相关的阈值。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。

  - 也可以**手动启动垃圾回收**，即使用`gc.collect()`。

  - **分代回收**

    - Python同时采用了**分代(generation)回收**的策略。

    - 这一策略的**基本假设**是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。

    - Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

    - 这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。

    - 同样可以用`set_threshold()`来调整，比如对2代对象进行更频繁的扫描。

      ```python
      import gc
      gc.set_threshold(700, 10, 5)
      ```

- **孤立的引用环**

  - 引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。
  - 为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。

- Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。

# 参考

- [参考一](http://www.cnblogs.com/vamei/p/3232088.html)